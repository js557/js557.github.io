{"meta":{"title":"js557's blog","subtitle":"","description":"","author":"js557","url":"https://1mu58z.coding-pages.com","root":"/"},"pages":[{"title":"about","date":"2020-03-18T09:17:47.000Z","updated":"2020-03-18T09:18:43.758Z","comments":true,"path":"about/index.html","permalink":"https://1mu58z.coding-pages.com/about/index.html","excerpt":"","text":"一个体贴善良可爱大方的大学生哇哈哈哈哈哈"},{"title":"分类","date":"2020-03-18T09:13:53.000Z","updated":"2020-03-18T09:15:19.862Z","comments":true,"path":"categories/index.html","permalink":"https://1mu58z.coding-pages.com/categories/index.html","excerpt":"","text":""},{"title":"tag","date":"2020-03-18T09:16:46.000Z","updated":"2020-03-18T09:17:18.502Z","comments":true,"path":"tags/index.html","permalink":"https://1mu58z.coding-pages.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Segments POJ 3304_叉乘+直线与线段相交+思维","slug":"SegmentsPOJ3304_叉乘+直线与线段相交+思维","date":"2020-05-28T23:54:21.862Z","updated":"2020-05-29T00:41:18.486Z","comments":true,"path":"2020/05/29/SegmentsPOJ3304_叉乘+直线与线段相交+思维/","link":"","permalink":"https://1mu58z.coding-pages.com/2020/05/29/SegmentsPOJ3304_%E5%8F%89%E4%B9%98+%E7%9B%B4%E7%BA%BF%E4%B8%8E%E7%BA%BF%E6%AE%B5%E7%9B%B8%E4%BA%A4+%E6%80%9D%E7%BB%B4/","excerpt":"code{ color:#C82850 ; background:#FAF0F5; } font{ color:blue; font-weight:bold; } 题目入口 题意：给出n条线段。问是否存在这样一条直线，使得各线段到这段直线的投影至少有一个交点。 题解：假设存在题目所说的这条直线，作这条直线的垂线，由于交点在这条直线上，因为投影是线段根据垂线映射下来的一部分，要使各线段的投影至少有一个交点，那么作经过这个交点的垂线，必定与所有线段相交。 所以，只要找出一条直线(即上述的垂线)能与所有线段都相交即可 该直线(垂线)至少经过所有线段中的两个端点","text":"code{ color:#C82850 ; background:#FAF0F5; } font{ color:blue; font-weight:bold; } 题目入口 题意：给出n条线段。问是否存在这样一条直线，使得各线段到这段直线的投影至少有一个交点。 题解：假设存在题目所说的这条直线，作这条直线的垂线，由于交点在这条直线上，因为投影是线段根据垂线映射下来的一部分，要使各线段的投影至少有一个交点，那么作经过这个交点的垂线，必定与所有线段相交。 所以，只要找出一条直线(即上述的垂线)能与所有线段都相交即可 该直线(垂线)至少经过所有线段中的两个端点 理由：假设所有线段的投影重合部分(这个部分以下简称C)只有一个点，那么只有两种情况： （1） 至少存在一条线段,与垂线平行(此时这条线段就有2个端点了) （2） 至少存在一条线段,只有端点P1的投影在C处，现在假设除了这一条，其他线段投影重合部分不止一个点。但同时也因为C处只有一个点，那么可以反证至少还存在第二条线段的端点P2的投影刚好在了重合处(否则第二条线段的投影就会越过C处，使得第一条线段的投影不止一个点，那么C也从而不止一个点，就违背了前面的假设)综上，以上两种情况，我们都能找到经过垂线的两个端点(P1和P2)。 所以，枚举所有点，从中取两个点作为我们所要找的垂线，利用叉乘判断这条垂线是否能与所有线段都相交即可(相交判断：以直线为基准，线段中的一个点在直线的左边，另一个点在直线的右边) 注意点（坑点） 考虑重合的点：如果两个点小于题目精度，则是重合点 叉乘判断那里，注意要以你利用2个端点来确定的直线为基准，不能以线段为基准，否则叉乘会有错，通过简单画图就可以印证 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include&lt;map&gt;#include&lt;cmath&gt;#include &lt;vector&gt;#define EPS 1e-8//精度using namespace std;struct Edge &#123; double x1, y1, x2, y2; Edge() : x1(0), y1(0), x2(0), y2(0) &#123;&#125; Edge(double _x1, double _y1, double _x2, double _y2) : x1(_x1), y1(_y1), x2(_x2), y2(_y2) &#123;&#125;&#125;;struct Point &#123; double x, y;&#125;;bool judge(Edge a,Edge b)&#123;//判断直线与线段是否相交 double x1,x2,y1,y2; x1=(b.x2-b.x1),y1=(b.y2-b.y1); x2=(a.x1-b.x1),y2=(a.y1-b.y1); double res1=x1*y2-x2*y1; x2 = (a.x2 - b.x1), y2 = (a.y2 - b.y1); double res2=x1*y2-x2*y1; if(res1*res2&lt;=EPS) return 1;//相交/重合 return 0;//不相交 &#125;bool judgePoint(Point a,Point b)&#123;//判断点是否重合，小于精度则重合 double res=(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y); res=sqrt(res); if(res&lt;=EPS) return 1;//同一个点 return 0;&#125;Point point[220];Edge edge[110];int main()&#123; ios::sync_with_stdio(false); int t,n; cin&gt;&gt;t; while(t--)&#123; memset(point,0,sizeof(point)); memset(edge,0,sizeof(edge)); cin&gt;&gt;n; for(int i=0;i&lt;2*n;i++)&#123; double a,b,c,d; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d; point[i].x=a;point[i].y=b;point[++i].x=c;point[i].y=d; int t=(i-1)/2; edge[t].x1=a,edge[t].y1=b,edge[t].x2=c,edge[t].y2=d; &#125; bool flag = 1; /* 找垂线。枚举两个点组成直线 */ for(int i=0;i&lt;2*n;i++)&#123; for(int j=i+1;j&lt;2*n;j++)&#123; flag=1; if(judgePoint(point[i],point[j])) continue;//坑点：判断重合点 Edge temp(point[i].x,point[i].y,point[j].x,point[j].y); for(int z=0;z&lt;n;z++)&#123;//取一条线段 bool res=judge(edge[z],temp); if(!res)&#123; flag=0; break; &#125; &#125; if(flag)&#123; cout &lt;&lt; \"Yes!\"&lt;&lt;endl; i=n*n; break; &#125; &#125; &#125; if(!flag)&#123; cout &lt;&lt; \"No!\"&lt;&lt;endl; &#125; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"带权并查集_How Many Answers Are Wrong","slug":"带权并查集_HowManyAnswersAreWrong","date":"2020-05-28T23:49:32.512Z","updated":"2020-05-29T00:40:29.975Z","comments":true,"path":"2020/05/29/带权并查集_HowManyAnswersAreWrong/","link":"","permalink":"https://1mu58z.coding-pages.com/2020/05/29/%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86_HowManyAnswersAreWrong/","excerpt":"code{ color:#C82850 ; background:#FAF0F5; } font{ color:blue; font-weight:bold; } 题目入口这道题有点巧妙~ 大致题意给定一个数组，每次给出l,r,value表示区间 [ l , r ] 的总和为value，但每次给出的value可能和前面的答案有冲突，求冲突次数。举例：好比如前面给出了[1,10]的和为100、[1,7]的和为60，那么自然就可以确定[8,10]的和为100-60=40，但题目术输出却给出[8,10]的和为80，那么就和前面的答案冲突了。 这道题的突破点在于，","text":"code{ color:#C82850 ; background:#FAF0F5; } font{ color:blue; font-weight:bold; } 题目入口这道题有点巧妙~ 大致题意给定一个数组，每次给出l,r,value表示区间 [ l , r ] 的总和为value，但每次给出的value可能和前面的答案有冲突，求冲突次数。举例：好比如前面给出了[1,10]的和为100、[1,7]的和为60，那么自然就可以确定[8,10]的和为100-60=40，但题目术输出却给出[8,10]的和为80，那么就和前面的答案冲突了。 这道题的突破点在于，可以以sum[ i ]看成区间 [ 0 , i ] 的总和（或称为距离），则变成了只看一个变量i，则可考虑用并查集。可以发现，只有当上面的举例那样的情况，才可以确定发生了冲突。那么没有冲突时，我们就合并两个点（集合）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn = 2e5 + 10;int a[maxn];int parent[maxn];ll sum[maxn] = &#123;0&#125;;//表示i到父节点的距离int find(int x) &#123; if (parent[x] != x) &#123; int t = parent[x]; parent[x] = find(parent[x]);//路径压缩 sum[x] += sum[t]; /* 经过路径压缩后，x的父节点由t变为了为根节点，t的父节点也变为了根节点，所以要刷新sum[x]的值(=sum[x]+sum[t]),sum[x]原本表示x到旧父节点t的距离，但现在应是x到新的父节点（根节点root）的距离，则为\"x到旧父节点t的距离+救父结点t到新父节点root的距离\" */ &#125; return parent[x];&#125;int main() &#123; ios::sync_with_stdio(false); int n, m; while(cin &gt;&gt; n &gt;&gt; m)&#123; memset(sum,0,sizeof(sum)); for (int i = 1; i &lt;= n + 5; i++) &#123; parent[i] = i; &#125; int res = 0; for (int i = 1; i &lt;= m; i++) &#123; int l, r, va; cin &gt;&gt; l &gt;&gt; r &gt;&gt; va; r++; //区间：左闭右开，避免端点重复求和 int fl = find(l), fr = find(r); if (fl != fr) &#123; parent[fl] = fr; sum[fl] = sum[r] + va - sum[l]; &#125; else &#123; if (va != sum[l] - sum[r]) &#123;//注意此处不是sum[r]-sum[l],画图可以看出 res++; // printf(\"%d---%d\\n\",i,res); &#125; &#125; &#125; cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"cf#599(div2)C - Tile Painting","slug":"cf#599(div2)C - Tile Painting","date":"2020-05-28T23:45:31.678Z","updated":"2020-05-29T00:38:19.894Z","comments":true,"path":"2020/05/29/cf#599(div2)C - Tile Painting/","link":"","permalink":"https://1mu58z.coding-pages.com/2020/05/29/cf#599(div2)C%20-%20Tile%20Painting/","excerpt":"题目入口这个题目有点意思~题目要求| i-j |&gt;1 &amp;&amp; n%| i-j |==0 所以|i-j|是n的因数。结论： 若n本身为质数，则一共有n种颜色。 只有一个质因子（=m），则m种颜色。 若n质因子个数&gt;=2，则所有格子都会有相同颜色，即结果为1。情况1、2很容易得出，画一下图很容易看出来。这里讨论第3种情况","text":"题目入口这个题目有点意思~题目要求| i-j |&gt;1 &amp;&amp; n%| i-j |==0 所以|i-j|是n的因数。结论： 若n本身为质数，则一共有n种颜色。 只有一个质因子（=m），则m种颜色。 若n质因子个数&gt;=2，则所有格子都会有相同颜色，即结果为1。情况1、2很容易得出，画一下图很容易看出来。这里讨论第3种情况其实推断一下就很容易发现，最多的颜色数&lt;=n的最小质因子。好比如15，因数有1,3,5,15。则每隔5个就有相同的颜色，即：格子1 6 11，2 7 12、3 8 13、4 9 14、5 10 15分别相同颜色，可以发现格子第1-5号可以直接表示了这5种颜色（因为后面的颜色分别和1-5中的一个颜色相同。） 又每隔3隔就有相同颜色，同理，格子1-3号表示了这3种颜色。 所以，初步推断，n个格子，最多颜色数&lt;=最小质因子。 为什么不是直接=最小质因子呢？令：m=“n的最小质因子”。用n=15这个例子，从115分为每连续3个一组，初步推断！！可知每组中的3个颜色两两不相同。接着往下一个质因子去推，以1为起点，每+5一次其实就相当于在第一组的13号中移动成对应的位置（其实相当于循环），因为若+3则移动到4，相当于1号位置（因为1和4的颜色相同），而+5即多移动了2个位置，所以第一次+5对应到了3号位置，第2次+5可对应到2号位置，第3次+5可对应到1号位置…可看出其实每一次+5，相当于在一个环形圈里移动位置，而只需移动m-1次即可遍历完所有的格子，得出结论——这些格子颜色都相同。 而格子一共只有n个，为什么就一定可以移动m-1次呢？∵ 比如n=15=35,对于这两个质因子，假设为x1,x2 则x1x2=n 若x1=3，x2=5，所以一共有x2个x1，而对于从1号位置开始，每次+5 得出的格子位置为1+x2t (t=1,2,3…)∴1+5t所以max(t)=x1-1，刚好可以遍历完所有格子。 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll solve(ll n)&#123; ll cnt=0; ll nn=n; for(ll i=2;i*i&lt;=n;i++)&#123; if(n%i==0)&#123; cnt++;//记录质因子个数 while(n%i==0)&#123; n/=i; &#125; if(n!=1) return 1;//说明&gt;=2个质因子 if(n==1)//说明只有一个质因子 return i; //返回最小质因子 &#125; &#125; return nn;//本身是质数 &#125;int main() &#123; ll n; scanf(\"%I64d\",&amp;n); printf(\"%I64d\",solve(n)); return 0;&#125;","categories":[],"tags":[]},{"title":"2019多校Calabash and Landlord_hdu6665（区域染色分块","slug":"2019多校Calabash and Landlord_hdu6665（区域染色分块","date":"2020-05-28T23:40:00.136Z","updated":"2020-05-29T00:34:45.503Z","comments":true,"path":"2020/05/29/2019多校Calabash and Landlord_hdu6665（区域染色分块/","link":"","permalink":"https://1mu58z.coding-pages.com/2020/05/29/2019%E5%A4%9A%E6%A0%A1Calabash%20and%20Landlord_hdu6665%EF%BC%88%E5%8C%BA%E5%9F%9F%E6%9F%93%E8%89%B2%E5%88%86%E5%9D%97/","excerpt":"题目入口问：在平面中的两个矩形可以将平面分成多少个区域？分析：可以看成是对区域进行染色。先把点离散化，并且在离散化时，将值设为原本离散化值的2倍—&gt;为了使矩形留出空格成块否则，如（0，0）和（1，1）组成的矩形在整个图（假设边为5的正方形图）中显示会如下所示","text":"题目入口问：在平面中的两个矩形可以将平面分成多少个区域？分析：可以看成是对区域进行染色。先把点离散化，并且在离散化时，将值设为原本离散化值的2倍—&gt;为了使矩形留出空格成块否则，如（0，0）和（1，1）组成的矩形在整个图（假设边为5的正方形图）中显示会如下所示 -1 -1 0 0 0-1 -1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 （-1表示矩形的边，0表示空白处）而因为矩形内也存在区域 所以正确的图应该如下-1 -1 -1 0 0-1 0 -1 0 0-1 -1 -1 0 0 0 0 0 0 0 0 0 0 0 0所以离散化时应该将值设为原本的2倍~然后跑一遍整幅图（此处大小设为了10*10），每跑完一次dfs相当于跑完一个区域，所以跑了多少遍dfs就是有多少个区域–&gt;即答案。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define N 10int a[N][N];int x[5],y[5];void init() &#123; int m[5],n[5]; for(int i=0; i&lt;4; i++) &#123; m[i]=x[i]; n[i]=y[i]; &#125; sort(m,m+4); sort(n,n+4); int len1=unique(m,m+4)-m; int len2=unique(n,n+4)-m; for(int i=0; i&lt;4; i++) &#123; x[i]=2*(lower_bound(m,m+4,x[i])-m+1);//为了正方形内空格 可打表观察 y[i]=2*(lower_bound(n,n+4,y[i])-n+1); &#125;&#125;int zb[4][2]= &#123;0,1,1,0,-1,0,0,-1&#125;;int ans=0;void dfs(int x,int y) &#123; int nx,ny; for(int i=0; i&lt;4; i++) &#123; nx=x+zb[i][0]; ny=y+zb[i][1]; if(nx&gt;=0&amp;&amp;nx&lt;N&amp;&amp;y&gt;=0&amp;&amp;y&lt;N&amp;&amp;a[nx][ny]==0) &#123; a[nx][ny]=ans; dfs(nx,ny); &#125; &#125;&#125;int main() &#123; int t; scanf(\"%d\",&amp;t); while(t--) &#123; for(int i=0; i&lt;4; i++) &#123; scanf(\"%d%d\",&amp;x[i],&amp;y[i]); &#125; init();//离散化 memset(a,0,sizeof(a)); for(int j=0; j&lt;2; j++) &#123; for(int i=x[2*j]; i&lt;=x[2*j+1]; i++) &#123; a[i][y[2*j]]=a[i][y[2*j+1]]=-1; &#125; for(int i=y[2*j]; i&lt;=y[2*j+1]; i++) &#123; a[x[2*j]][i]=a[x[2*j+1]][i]=-1; &#125; &#125; ans=0; for(int i=0; i&lt;N; i++) &#123; for(int j=0; j&lt;N; j++) &#123; if(a[i][j]==0) &#123; ans++; dfs(i,j); &#125; &#125; &#125; printf(\"%d\\n\",ans); &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"Roundgod and Milk Tea_hdu6667(贪心)","slug":"Roundgod and Milk Tea_hdu6667(贪心)","date":"2020-05-28T23:39:21.534Z","updated":"2020-05-29T00:38:43.863Z","comments":true,"path":"2020/05/29/Roundgod and Milk Tea_hdu6667(贪心)/","link":"","permalink":"https://1mu58z.coding-pages.com/2020/05/29/Roundgod%20and%20Milk%20Tea_hdu6667(%E8%B4%AA%E5%BF%83)/","excerpt":"这个也是思维题吧。。 used：之前被拿了的奶茶总数 若之前的人拿到的奶茶总数&lt;=当前的奶茶数，说明之前被拿了的奶茶可以换成拿的是当前的奶茶，使得当前的人可以拿除了a[i].p之外的任意奶茶； 若之前的人拿到的奶茶总数&gt;当前的奶茶数，","text":"这个也是思维题吧。。 used：之前被拿了的奶茶总数 若之前的人拿到的奶茶总数&lt;=当前的奶茶数，说明之前被拿了的奶茶可以换成拿的是当前的奶茶，使得当前的人可以拿除了a[i].p之外的任意奶茶； 若之前的人拿到的奶茶总数&gt;当前的奶茶数，依然是将等量当前的奶茶换成被拿了的奶茶，这样就可以保证当前的人拿的都是除a[i].p以外的奶茶，而多出来的（即used-a[i].p）奶茶则按照他们原先的分配，所以一共能拿的任意奶茶是sum-used 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6+5;#define ll long long struct node&#123; ll s,p;&#125;a[N];ll sum=0;int n;void solve()&#123; ll res=0;//对于当前的人，可从res杯奶茶中分配 ll used=0;//已经分派了的牛奶总数 for(int i=1;i&lt;=n;i++)&#123; if(used&lt;=a[i].p)&#123; res=sum-a[i].p;//说明被拿了的奶茶可以换成当前的奶茶，使得当前的人可以除了a[i].p拿到任意奶茶 &#125;else&#123;//依然是将被拿了的奶茶换成等量当前的奶茶，这样就可以保证当前的人拿的是除a[i].p以外的奶茶，而多出来的（即used-a[i].p）奶茶则按照他们原先的分配，所以一共能拿的任意奶茶是sum-used res=sum-used; &#125; used += min(a[i].s,res); &#125; printf(\"%lld\\n\",used);&#125; int main()&#123; int t; scanf(\"%d\",&amp;t); while(t--)&#123; scanf(\"%d\",&amp;n); sum=0;//总牛奶数 for(int i=1;i&lt;=n;i++)&#123; scanf(\"%lld%lld\",&amp;a[i].s,&amp;a[i].p); sum+=a[i].p; &#125; solve(); &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"2017沈阳网络赛transaction transaction transaction_hdu6201超级汇点跑SPFA","slug":"2017沈阳网络赛transaction transaction transaction_hdu6201超级汇点跑SPFA","date":"2020-05-28T23:35:33.172Z","updated":"2020-05-29T00:34:34.482Z","comments":true,"path":"2020/05/29/2017沈阳网络赛transaction transaction transaction_hdu6201超级汇点跑SPFA/","link":"","permalink":"https://1mu58z.coding-pages.com/2020/05/29/2017%E6%B2%88%E9%98%B3%E7%BD%91%E7%BB%9C%E8%B5%9Btransaction%20transaction%20transaction_hdu6201%E8%B6%85%E7%BA%A7%E6%B1%87%E7%82%B9%E8%B7%91SPFA/","excerpt":"code{ color:#C82850 ; background:#FAF0F5; } font{ color:blue; font-weight:bold; } 题目入口巧妙之处：建立超级源点和超级汇点，让多源问题变成单源问题 建立超级源点0和超级汇点n+1。 让超级源点（作为起点）连树上所有的点，边权分别为 -a[i]，表示买书花费； 所有树上所有点连接汇点，边权为a[i]，表示卖书花费， 原本的树上两两点之间的边权设为边权为-w，表示花费w。 然后spfa跑个最长路，答案为dis[超级汇点n+1]。","text":"code{ color:#C82850 ; background:#FAF0F5; } font{ color:blue; font-weight:bold; } 题目入口巧妙之处：建立超级源点和超级汇点，让多源问题变成单源问题 建立超级源点0和超级汇点n+1。 让超级源点（作为起点）连树上所有的点，边权分别为 -a[i]，表示买书花费； 所有树上所有点连接汇点，边权为a[i]，表示卖书花费， 原本的树上两两点之间的边权设为边权为-w，表示花费w。 然后spfa跑个最长路，答案为dis[超级汇点n+1]。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e5+10;const int INF = 0x3f3f3f3f;struct Edge&#123; int v; int cost; Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt; E[MAXN]; void addedge(int u, int v, int w)&#123; E[u].push_back(Edge(v, w));&#125;bool vis[MAXN]; //在队列标志int cnt[MAXN]; //每个点的入队列次数int dist[MAXN];bool SPFA(int start, int n)&#123; memset(vis, false, sizeof(vis)); memset(cnt, 0, sizeof(cnt)); for (int i = 0; i &lt;= n+1; i++) dist[i] = -INF; vis[start] = true; dist[start] = 0; cnt[start] = 1; queue&lt;int&gt; que; while (!que.empty()) que.pop(); que.push(start); while (!que.empty()) &#123; int u = que.front(); que.pop(); vis[u] = false; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[u][i].v; if (dist[v] &lt; dist[u] + E[u][i].cost) &#123; dist[v] = dist[u] + E[u][i].cost; if (!vis[v]) &#123; vis[v] = true; que.push(v); if (++cnt[v] &gt; n) return false; //cnt[i] 为入队列次数，用来判定是否存在负环回路 &#125; &#125; &#125; &#125; return true;&#125;int arr[MAXN],n;int main()&#123; int T; scanf(\"%d\",&amp;T); while(T--)&#123; for(int i=0;i&lt;=n+1;i++)&#123; E[i].clear(); &#125; scanf(\"%d\",&amp;n); int s=0,t=n+1;//超级源点 和 超级汇点 for(int i=1;i&lt;=n;i++)&#123; scanf(\"%d\",&amp;arr[i]); addedge(s,i,-arr[i]); addedge(i,t,arr[i]); &#125; int u,v,w; for(int i=0;i&lt;n-1;i++)&#123; scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); addedge(u,v,-w); addedge(v,u,-w);//无向图 &#125; SPFA(s,n); printf(\"%d\\n\",dist[t]); &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"Connections in Galaxy War并查集（逆向）","slug":"Connections in Galaxy War并查集（逆向）","date":"2020-05-28T23:32:09.094Z","updated":"2020-05-29T00:42:46.409Z","comments":true,"path":"2020/05/29/Connections in Galaxy War并查集（逆向）/","link":"","permalink":"https://1mu58z.coding-pages.com/2020/05/29/Connections%20in%20Galaxy%20War%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%88%E9%80%86%E5%90%91%EF%BC%89/","excerpt":"Connections in Galaxy Wara参考了一下网上的代码~做个思路记录","text":"Connections in Galaxy Wara参考了一下网上的代码~做个思路记录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;map&gt;#define N 10005#define M 20005#define Q 50005using namespace std;/*逆向思考的并查集题意： 给出power值 问题：1 查找某点能到达的power值最大的点 2 删除给出的边（在做删除此边的操作之前的查询，此边依旧可连通） 若正向思考，则无法删除边 所以，是逆向的并查集 方法： 先把所有的问题存储起来 合并除了要删除的边以外！的所有的边---&gt;得出parent树---&gt;以拥有最大power的点为树的根节点 倒序遍历问题---&gt;若是查询操作，则直接输出该店 ---&gt;若是删除边操作，则将该边添加！！！回去树中，以使该边存在于前面的查询操作！！！！！！！ */struct side&#123; int x,y;&#125;s[M];struct problem&#123; int x,y; char c[10];&#125;p[Q];map&lt;int ,bool&gt; mp;int res[Q];int power[N];int parent[N];int find(int x)&#123; return x==parent[x]?x:find(parent[x]);&#125;void merge(int x,int y)&#123; int rx=find(x),ry=find(y); if(power[rx]&gt;power[ry])&#123; parent[ry]=rx; &#125;else if(power[rx]&lt;power[ry])&#123; parent[rx]=ry; &#125;else&#123; if(rx&lt;ry)&#123; parent[ry]=rx; &#125;else&#123; parent[rx]=ry; &#125; &#125;&#125;int main()&#123; int n,m,q; int empty=0; while(~scanf(\"%d\",&amp;n))&#123; mp.clear(); for(int i=0;i&lt;n;i++)&#123; parent[i]=i; &#125; memset(res,-1,sizeof(res)); for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;power[i]); &#125; scanf(\"%d\",&amp;m); for(int i=0;i&lt;m;i++)&#123; scanf(\"%d%d\",&amp;s[i].x,&amp;s[i].y); if(s[i].x&gt;s[i].y) swap(s[i].x,s[i].y);//因为是无向边，所以统一前小后大的顺序，避免后面删除边时输入的大小顺序不一致，导致mp的值不一样 mp[s[i].x * 10000 + s[i].y] = false; //标记技巧：点的范围是[0,10000)],所以此处的标记保证了x*10000+y不重复！！！ &#125; scanf(\"%d\", &amp;q); for(int i=0;i&lt;q;i++)&#123;//将查询/破坏信息存储起来 scanf(\"%s\",p[i].c); if(p[i].c[0]=='q')&#123; scanf(\"%d\",&amp;p[i].x); &#125;else&#123; scanf(\"%d%d\",&amp;p[i].x,&amp;p[i].y); if(p[i].x&gt;p[i].y) swap(p[i].x,p[i].y);//记得要做交换 mp[p[i].x*10000+p[i].y]=true;//将要破坏的边标记起来， &#125;//技巧：此处的标记保证了x*10000+y不重复！！！！！！ &#125; for(int i=0;i&lt;m;i++)&#123;//将不被破坏的边合并起来 if(mp[s[i].x*10000+s[i].y]==false)&#123; merge(s[i].x,s[i].y); &#125; &#125; int cnt=0; for(int i=q-1;i&gt;=0;i--)&#123;//逆序判断，如果当前问题时破环，则把这条边添加回去（因为前面的询问这条边还未破坏） if(p[i].c[0]=='q')&#123; int rx=find(p[i].x); if(power[rx]&gt;power[p[i].x])&#123; res[cnt++]=rx; &#125;else&#123; res[cnt++]=-1; &#125; &#125;else&#123; merge(p[i].x,p[i].y); &#125; &#125; if(empty)&#123; printf(\"\\n\"); &#125;else&#123; empty=1; &#125; for(int i=cnt-1;i&gt;=0;i--)&#123; printf(\"%d\\n\",res[i]); &#125; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"隐式类型转换","slug":"隐式类型转换","date":"2020-05-27T18:25:12.208Z","updated":"2020-05-29T00:35:49.861Z","comments":true,"path":"2020/05/28/隐式类型转换/","link":"","permalink":"https://1mu58z.coding-pages.com/2020/05/28/%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"code{ color:#C82850 ; background:#FAF0F5; } font{ color:blue; font-weight:bold; } 定义是自动执行的，不需要程序员显示的转换的就是隐式转换，如：int a = 5.2 + 1;此时发生了类型转换。因为5.2是一个浮点数，5.2转换为了int类型 内置类型的隐式转换太简单，略类类型的隐式转换如果构造函数只接受一个实参，则它实际上定义了从实参类型转换为此类类型的隐式转换机制，有时我们把这种构造函数称作转换构造函数。注意：此处说的是一个实参，不代表形参只有一个，形参可以是多个，其余的有默认值即可 例子： 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;class Book &#123; private: string bookNo; double price; //通过设置默认值，定义一个[只有一个实参]时也能调用的构造函数 public: Book(string _bookNo, double _price = 0) : bookNo(_bookNo), price(_price) &#123;&#125; //比较bookNo bool cmp(const Book&amp; book) &#123; return (*this).bookNo == book.bookNo; &#125;&#125;;int main() &#123; Book a(\"one\"); cout&lt;&lt;a.cmp(string(\"two\"));//0 cout&lt;&lt;a.cmp(string(\"one\"));//1 return 0;&#125; 上述例子中，","text":"code{ color:#C82850 ; background:#FAF0F5; } font{ color:blue; font-weight:bold; } 定义是自动执行的，不需要程序员显示的转换的就是隐式转换，如：int a = 5.2 + 1;此时发生了类型转换。因为5.2是一个浮点数，5.2转换为了int类型 内置类型的隐式转换太简单，略类类型的隐式转换如果构造函数只接受一个实参，则它实际上定义了从实参类型转换为此类类型的隐式转换机制，有时我们把这种构造函数称作转换构造函数。注意：此处说的是一个实参，不代表形参只有一个，形参可以是多个，其余的有默认值即可 例子： 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;class Book &#123; private: string bookNo; double price; //通过设置默认值，定义一个[只有一个实参]时也能调用的构造函数 public: Book(string _bookNo, double _price = 0) : bookNo(_bookNo), price(_price) &#123;&#125; //比较bookNo bool cmp(const Book&amp; book) &#123; return (*this).bookNo == book.bookNo; &#125;&#125;;int main() &#123; Book a(\"one\"); cout&lt;&lt;a.cmp(string(\"two\"));//0 cout&lt;&lt;a.cmp(string(\"one\"));//1 return 0;&#125; 上述例子中，以a.cmp(string(“two”))为例，可见成功调用了cmp比较。但cmp的形参是一个Book类型，而我们传入的实参是string类型，实际上这里就是发生了隐式类类型转换！可以看到，我们有一个Book(string _bookNo, double _price = 0)这样的的构造函数，由于bookNo后的形参采用了默认值，因此我们可以只通过一个实参就调用这个构造函数当我们调用a.cmp(string(“two”))时： string(“two)调用了构造函数——Book(string _bookNo, double _price = 0)，通过这个构造函数生成了一个临时的Book对象b 然后上述生成的对象b来作为cmp(const Book&amp; book)中的形参，成功调用cmp函数 注意：对于类类型的隐式转换，编译器只会自动地执行1步类类型转换例子 123cout&lt;&lt;a.cmp(\"two\");// × 表达1cout&lt;&lt;a.cmp(string(\"two\"));// √ 表达2cout&lt;&lt;a.cmp(Book(\"three\"));// √ 表达3 对于表达1，就需要进行了2次的隐式转换，因此是错误的表达。隐式转换过程如下： 第一次是将”two”转换为string 第二次是将第一次转换过来的string转换为Book对于表达2，只进行了string隐式转换为Book，因此可行 抑制构造函数定义的隐式转换将构造函数声明为explicit即可即将构造函数改为： 1explicit Book(string _bookNo, double _price = 0) : bookNo(_bookNo), price(_price) &#123;&#125; 参考资料：C++ Prime 第五版","categories":[],"tags":[]},{"title":"c++lambda表达式","slug":"c++lambda表达式","date":"2020-05-27T09:59:22.286Z","updated":"2020-05-27T10:36:20.011Z","comments":true,"path":"2020/05/27/c++lambda表达式/","link":"","permalink":"https://1mu58z.coding-pages.com/2020/05/27/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"code{ color:#C82850 ; background:#FAF0F5; } 说明： lambda表达式其实可以直接看做是一个函数 lambda表达式实际上可以转换成等价的类！ 用法：[capture](parameters) mutable ->return-type{statement} 最大优势：可以以值传递/引用方式捕捉到上下文的变量，共lambda函数使用 用法详细说明：","text":"code{ color:#C82850 ; background:#FAF0F5; } 说明： lambda表达式其实可以直接看做是一个函数 lambda表达式实际上可以转换成等价的类！ 用法：[capture](parameters) mutable ->return-type{statement} 最大优势：可以以值传递/引用方式捕捉到上下文的变量，共lambda函数使用 用法详细说明： 1.[capture]：捕捉列表。捕捉到的变量供lamb函数使用。相当于类中的成员变量 2.(parameters)：函数的参数列表。如果不需要参数传递，则可以连同括号“()”一起省略; 3.mutable：mutable修饰符。默认情况下，Lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）; 4.->return-type：返回类型。用追踪返回类型形式声明函数的返回类型。我们可以在不需要返回值的时候也可以连同符号”-&gt;”一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导; 5.{statement}：函数体。除了可以使用参数列表中的参数之外，还可使用捕获到的变量。 其中：[captrue]规则1.[var]表示值传递方式捕捉变量var；2.[=]表示值传递方式捕捉所有父作用域的变量（包括this）；3.[&amp;var]表示引用传递捕捉变量var；4.[&amp;]表示引用传递方式捕捉所有父作用域的变量（包括this）；5.[this]表示值传递方式捕捉当前的this指针。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;using namespace std;class Cmp &#123; public: int z; public: bool cmp(const int a) const &#123; // z=5;//错误，const成员函数不可以修改非static成员变量 return z &lt; a; &#125;&#125;;int main() &#123; //--------------例1---------------- int z = 1; //该lambda表达式就等同于Cmp类，[]里的值相当于类中的成员变量, //(const int a)相当于类中cmp函数的形参列表 auto const_a = [z](const int a) -&gt; bool &#123; // z=5;//这句是错的，因为lambda表达式不带mutable就是一个const函数，而const修饰成员函数是不可以改变类中非static成员变量的 return z &gt; a; &#125;; cout &lt;&lt; \"const_a(2)=\" &lt;&lt; const_a(2) &lt;&lt; endl&lt;&lt;endl; //--------------例2---------------- int val = 0; auto mutable_val = [=]() mutable &#123; val = 3; cout &lt;&lt; \"_mutable_inner_val=\" &lt;&lt; val &lt;&lt; endl; // 3 &#125;; mutable_val(); cout &lt;&lt; \"mutable_val=\" &lt;&lt; val &lt;&lt; endl &lt;&lt; endl;// 0 /* 使用了mutable改变了lambda函数默认的const属性， * 但以值传递的方式在lambda函数体内修改val,只不过是修改了拷贝过来的局部变量val, * 就像swap(inta,int b)&#123;int t;t=a,a=b,b=t;&#125;, * 形参ab都是值传递过来的,当调用的时候使用的是swap(c,d), * 等完成了swap函数体,并不会改变实参,也就不会交换cd的值 */ // 重点-当使用引用时，注意点！！！ //--------------例3---------------- val = 0; auto const_ref = [&amp;]() &#123; val = 4; &#125;; const_ref(); cout &lt;&lt; \"const_ref_val=\" &lt;&lt; val &lt;&lt; endl; // val=4 虽在const函数，但改变了val!!! //--------------例4---------------- auto mutable_ref_lambda = [&amp;]() mutable &#123; val = 5; &#125;; mutable_ref_lambda(); cout &lt;&lt; \"mutable_ref_val\" &lt;&lt; val &lt;&lt; endl; // val=5 return 0;&#125; 参考资料:https://blog.csdn.net/u010984552/article/details/53634513","categories":[],"tags":[]},{"title":"hexo下建blog的坑点","slug":"hexo的next主题设置来必力评论坑点","date":"2020-03-17T15:50:34.000Z","updated":"2020-05-27T10:14:08.643Z","comments":true,"path":"2020/03/17/hexo的next主题设置来必力评论坑点/","link":"","permalink":"https://1mu58z.coding-pages.com/2020/03/17/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E6%9D%A5%E5%BF%85%E5%8A%9B%E8%AF%84%E8%AE%BA%E5%9D%91%E7%82%B9/","excerpt":"code{ color:#C82850 ; background:#FAF0F5; } 坑点1——来必力评论不显示 用了最新版的next，找了很多篇配置讲解都是说，注册了来必力之后，把“来必力安装代码”中data-uid的值，直接替换掉主题配置文件中设置livere_uid的值就好，但是弄了很久，也不知道是我的next问题还是怎么样，评论区一直没加载进来。 获取来必力data-uid 替换主题配置文件_config.yml中的livere_uid123# LiveRe comments system# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: MTAyMC80OTE1MS8yNTY0NQ== 直到我换了next四个主题中的其中一个之后，评论区就科幻的成功加载进来了！！！","text":"code{ color:#C82850 ; background:#FAF0F5; } 坑点1——来必力评论不显示 用了最新版的next，找了很多篇配置讲解都是说，注册了来必力之后，把“来必力安装代码”中data-uid的值，直接替换掉主题配置文件中设置livere_uid的值就好，但是弄了很久，也不知道是我的next问题还是怎么样，评论区一直没加载进来。 获取来必力data-uid 替换主题配置文件_config.yml中的livere_uid123# LiveRe comments system# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: MTAyMC80OTE1MS8yNTY0NQ== 直到我换了next四个主题中的其中一个之后，评论区就科幻的成功加载进来了！！！ 换主题方法在主题配置文件(themes/next/config.yml)中，搜索Schemes就会找到主题模块，切换成你想要的主题即可。 12345# Schemes#scheme: Musescheme: Mist#scheme: Pisces#scheme: Gemini 不过，试了好多次之后又发现，有时候评论区也没有加载进来，个人觉得…可能是因为本身就加载慢。 坑点2——文章导入本地图片不显示按网上常规步骤弄完，图片仍不显示！ 博客文章导入图片步骤1.去站点配置文件_config.yml中：将post_asset_folder: false改为post_asset_folder: true2.站点下安装插件npm install https://github.com/CodeFalling/hexo-asset-image -- save3.运行hexo n \"你的文件名\"，就会在source/_posts/路径下分别生成名为\"你的文件名.md\"的md文件和文件夹。将你要在文章中引入的图片放到这个文件夹下即可。 但是！并没有成功显示图片 替换插件内容最后在CSND看到一篇文章，原来是因为前面安装的hexo-asset-image这个插件有bug，于是在/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123;return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split('.');hexo.extend.filter.register('after_post_render', function(data)&#123;var config = hexo.config;if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, '/', 1) + 1; else var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of \"about\" page is like \".../about/index.html\". var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $('img').each(function()&#123; if ($(this).attr('src'))&#123; // For windows style path, we replace '\\' to '/'. var src = $(this).attr('src').replace('\\\\', '/'); if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) &#123; // For \"about\" page, the first part of \"src\" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem)&#123; return elem != ''; &#125;); var srcArray = src.split('/').filter(function(elem)&#123; return elem != '' &amp;&amp; elem != '.'; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); $(this).attr('src', config.root + link + src); console.info&amp;&amp;console.info(\"update link as:--&gt;\"+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(\"no src attr, skipped...\"); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125;&#125;&#125;); 成功！撒花onYeah!","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-03-17T02:33:37.042Z","updated":"2020-03-17T16:05:00.047Z","comments":true,"path":"2020/03/17/hello-world/","link":"","permalink":"https://1mu58z.coding-pages.com/2020/03/17/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}