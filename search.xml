<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Segments POJ 3304_叉乘+直线与线段相交+思维</title>
    <url>/2020/05/29/SegmentsPOJ3304_%E5%8F%89%E4%B9%98+%E7%9B%B4%E7%BA%BF%E4%B8%8E%E7%BA%BF%E6%AE%B5%E7%9B%B8%E4%BA%A4+%E6%80%9D%E7%BB%B4/</url>
    <content><![CDATA[<style>
    code{
        color:#C82850 ;
        background:#FAF0F5;
    }
    font{
        color:blue;
        font-weight:bold;
    }
</style>
<p><a href="http://poj.org/problem?id=3304" target="_blank" rel="noopener">题目入口</a></p>
<h6 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h6><p>给出n条线段。问是否存在这样一条直线，使得各线段到这段直线的投影至少有一个交点。</p>
<h6 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h6><p>假设存在题目所说的这条直线，作这条直线的垂线，<br>由于交点在这条直线上，因为投影是线段根据垂线映射下来的一部分，<br>要使各线段的投影至少有一个交点，那么作经过这个交点的垂线，必定与所有线段相交。</p>
<ol>
<li>所以，只要找出一条直线(即上述的垂线)能与所有线段都相交即可</li>
<li>该直线(垂线)至少经过所有线段中的两个端点<a id="more"></a><br> 理由：假设所有线段的投影重合部分(这个部分以下简称C)只有一个点，那么只有两种情况：<br> （1） 至少存在一条线段,与垂线平行(此时这条线段就有2个端点了)<br> （2） 至少存在一条线段,只有端点P1的投影在C处，现在假设除了这一条，其他线段投影重合部分不止一个点。但同时也因为C处只有一个点，那么可以反证至少还存在第二条线段的端点P2的投影刚好在了重合处(否则第二条线段的投影就会越过C处，使得第一条线段的投影不止一个点，那么C也从而不止一个点，就违背了前面的假设)<br><code>综上，以上两种情况，我们都能找到经过垂线的两个端点(P1和P2)。</code></li>
</ol>
<p><code>所以，枚举所有点，从中取两个点作为我们所要找的垂线，利用叉乘判断这条垂线是否能与所有线段都相交即可(相交判断：以直线为基准，线段中的一个点在直线的左边，另一个点在直线的右边)</code></p>
<h6 id="注意点（坑点）"><a href="#注意点（坑点）" class="headerlink" title="注意点（坑点）"></a>注意点（坑点）</h6><ol>
<li>考虑重合的点：如果两个点小于题目精度，则是重合点</li>
<li>叉乘判断那里，注意要以你利用2个端点来确定的直线为基准，不能以线段为基准，否则叉乘会有错，通过简单画图就可以印证</li>
</ol>
<p><img src="/2020/05/29/SegmentsPOJ3304_%E5%8F%89%E4%B9%98+%E7%9B%B4%E7%BA%BF%E4%B8%8E%E7%BA%BF%E6%AE%B5%E7%9B%B8%E4%BA%A4+%E6%80%9D%E7%BB%B4/1.png" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPS 1e-8<span class="comment">//精度</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x1, y1, x2, y2;</span><br><span class="line">    Edge() : x1(<span class="number">0</span>), y1(<span class="number">0</span>), x2(<span class="number">0</span>), y2(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Edge(<span class="keyword">double</span> _x1, <span class="keyword">double</span> _y1, <span class="keyword">double</span> _x2, <span class="keyword">double</span> _y2)</span><br><span class="line">        : x1(_x1), y1(_y1), x2(_x2), y2(_y2) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(Edge a,Edge b)</span></span>&#123;<span class="comment">//判断直线与线段是否相交</span></span><br><span class="line">    <span class="keyword">double</span> x1,x2,y1,y2;</span><br><span class="line">    x1=(b.x2-b.x1),y1=(b.y2-b.y1);</span><br><span class="line">    x2=(a.x1-b.x1),y2=(a.y1-b.y1);</span><br><span class="line">    <span class="keyword">double</span> res1=x1*y2-x2*y1;</span><br><span class="line">    x2 = (a.x2 - b.x1), y2 = (a.y2 - b.y1);</span><br><span class="line">    <span class="keyword">double</span> res2=x1*y2-x2*y1;</span><br><span class="line">    <span class="keyword">if</span>(res1*res2&lt;=EPS)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//相交/重合</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//不相交</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judgePoint</span><span class="params">(Point a,Point b)</span></span>&#123;<span class="comment">//判断点是否重合，小于精度则重合</span></span><br><span class="line">    <span class="keyword">double</span> res=(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);</span><br><span class="line">    res=<span class="built_in">sqrt</span>(res);</span><br><span class="line">    <span class="keyword">if</span>(res&lt;=EPS)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//同一个点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Point <span class="built_in">point</span>[<span class="number">220</span>];</span><br><span class="line">Edge edge[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> t,n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(<span class="built_in">point</span>,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="built_in">point</span>));</span><br><span class="line">        <span class="built_in">memset</span>(edge,<span class="number">0</span>,<span class="keyword">sizeof</span>(edge));</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">            <span class="keyword">double</span> a,b,c,d;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">            <span class="built_in">point</span>[i].x=a;<span class="built_in">point</span>[i].y=b;<span class="built_in">point</span>[++i].x=c;<span class="built_in">point</span>[i].y=d;</span><br><span class="line">            <span class="keyword">int</span> t=(i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">            edge[t].x1=a,edge[t].y1=b,edge[t].x2=c,edge[t].y2=d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 找垂线。枚举两个点组成直线 */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;<span class="number">2</span>*n;j++)&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(judgePoint(<span class="built_in">point</span>[i],<span class="built_in">point</span>[j]))  <span class="keyword">continue</span>;<span class="comment">//坑点：判断重合点</span></span><br><span class="line">                <span class="function">Edge <span class="title">temp</span><span class="params">(<span class="built_in">point</span>[i].x,<span class="built_in">point</span>[i].y,<span class="built_in">point</span>[j].x,<span class="built_in">point</span>[j].y)</span></span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> z=<span class="number">0</span>;z&lt;n;z++)&#123;<span class="comment">//取一条线段</span></span><br><span class="line">                    <span class="keyword">bool</span> res=judge(edge[z],temp);</span><br><span class="line">                    <span class="keyword">if</span>(!res)&#123;</span><br><span class="line">                        flag=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    i=n*n;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"No!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>带权并查集_How Many Answers Are Wrong</title>
    <url>/2020/05/29/%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86_HowManyAnswersAreWrong/</url>
    <content><![CDATA[<style>
    code{
        color:#C82850 ;
        background:#FAF0F5;
    }
    font{
        color:blue;
        font-weight:bold;
    }
</style>

<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3038" target="_blank" rel="noopener">题目入口</a><br>这道题有点巧妙~</p>
<h6 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h6><p>给定一个数组，每次给出l,r,value表示区间 [ l , r ] 的总和为value，但每次给出的value可能和前面的答案有冲突，求冲突次数。<br><b>举例：</b>好比如前面给出了[1,10]的和为100、[1,7]的和为60，那么自然就可以确定[8,10]的和为100-60=40，但题目术输出却给出[8,10]的和为80，那么就和前面的答案冲突了。</p>
<p><code>这道题的突破点在于，</code><a id="more"></a>可以以sum[ i ]看成区间 [ 0 , i ] 的总和（或称为距离），则变成了只看一个变量i，则可考虑用并查集。可以发现，只有当上面的举例那样的情况，才可以确定发生了冲突。那么没有冲突时，我们就合并两个点（集合）。</p>
<p><img src="/2020/05/29/%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86_HowManyAnswersAreWrong/1.png" alt="avatar"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> parent[maxn];</span><br><span class="line">ll sum[maxn] = &#123;<span class="number">0</span>&#125;;<span class="comment">//表示i到父节点的距离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = parent[x];</span><br><span class="line">        parent[x] = <span class="built_in">find</span>(parent[x]);<span class="comment">//路径压缩</span></span><br><span class="line">        sum[x] += sum[t]; </span><br><span class="line">            <span class="comment">/*  经过路径压缩后，x的父节点由t变为了为根节点，t的父节点也变为了根节点，所以要刷新sum[x]的值(=sum[x]+sum[t]),sum[x]原本表示x到旧父节点t的距离，但现在应是x到新的父节点（根节点root）的距离，则为"x到旧父节点t的距离+救父结点t到新父节点root的距离" */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span>(sum));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">5</span>; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l, r, va;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; va;</span><br><span class="line">            r++;  <span class="comment">//区间：左闭右开，避免端点重复求和</span></span><br><span class="line">            <span class="keyword">int</span> fl = <span class="built_in">find</span>(l), fr = <span class="built_in">find</span>(r);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fl != fr) &#123;</span><br><span class="line">                parent[fl] = fr;</span><br><span class="line">                sum[fl] = sum[r] + va - sum[l];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (va != sum[l] - sum[r]) &#123;<span class="comment">//注意此处不是sum[r]-sum[l],画图可以看出</span></span><br><span class="line">                    res++;</span><br><span class="line">                 <span class="comment">//   printf("%d---%d\n",i,res);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>cf#599(div2)C - Tile Painting</title>
    <url>/2020/05/29/cf#599(div2)C%20-%20Tile%20Painting/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/contest/1243/problem/C" target="_blank" rel="noopener">题目入口</a><br>这个题目有点意思~<br>题目要求| i-j |&gt;1 &amp;&amp; n%| i-j |==0  所以|i-j|是n的因数。<br><b>结论：</b></p>
<ol>
<li>若n本身为质数，则一共有n种颜色。</li>
<li>只有一个质因子（=m），则m种颜色。</li>
<li>若n质因子个数&gt;=2，则所有格子都会有相同颜色，即结果为1。<br>情况1、2很容易得出，画一下图很容易看出来。这里讨论第3种情况<a id="more"></a><br>其实推断一下就很容易发现，最多的颜色数&lt;=n的最小质因子。<br>好比如15，因数有1,3,5,15。<br>则每隔5个就有相同的颜色，即：<br>格子1 6 11，2 7 12、3 8 13、4 9 14、5 10 15分别相同颜色，可以发现格子第1-5号可以直接表示了这5种颜色（因为后面的颜色分别和1-5中的一个颜色相同。）</li>
</ol>
<p>又每隔3隔就有相同颜色，同理，格子1-3号表示了这3种颜色。</p>
<p>所以，<b>初步推断</b>，n个格子，最多颜色数&lt;=最小质因子。</p>
<p>为什么不是直接=最小质因子呢？<br><u>令：m=“n的最小质因子”。</u><br>用n=15这个例子，从1<del>15分为每连续3个一组，初步推断！！可知每组中的3个颜色两两不相同。接着往下一个质因子去推，以1为起点，每+5一次其实就相当于在第一组的1</del>3号中移动成对应的位置（其实相当于循环），因为若+3则移动到4，相当于1号位置（因为1和4的颜色相同），而+5即多移动了2个位置，所以第一次+5对应到了3号位置，第2次+5可对应到2号位置，第3次+5可对应到1号位置…可看出其实每一次+5，相当于在一个环形圈里移动位置，而只需移动m-1次即可遍历完所有的格子，得出结论——这些格子颜色都相同。</p>
<p>而格子一共只有n个，为什么就一定可以移动m-1次呢？<br>∵ 比如n=15=3<em>5,对于这两个质因子，假设为x1,x2  则x1</em>x2=n  若x1=3，x2=5，所以一共有x2个x1，而对于从1号位置开始，每次+5 得出的格子位置为1+x2<em>t (t=1,2,3…)<br>∴1+5</em>t所以max(t)=x1-1，刚好可以遍历完所有格子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">	ll cnt=<span class="number">0</span>;</span><br><span class="line">	ll nn=n;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">2</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">			cnt++;<span class="comment">//记录质因子个数 </span></span><br><span class="line">			<span class="keyword">while</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">				n/=i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(n!=<span class="number">1</span>)	</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//说明&gt;=2个质因子 </span></span><br><span class="line">			<span class="keyword">if</span>(n==<span class="number">1</span>)<span class="comment">//说明只有一个质因子 </span></span><br><span class="line">				<span class="keyword">return</span> i; <span class="comment">//返回最小质因子 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> nn;<span class="comment">//本身是质数 </span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%I64d"</span>,&amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%I64d"</span>,solve(n));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>2019多校Calabash and Landlord_hdu6665（区域染色分块</title>
    <url>/2020/05/29/2019%E5%A4%9A%E6%A0%A1Calabash%20and%20Landlord_hdu6665%EF%BC%88%E5%8C%BA%E5%9F%9F%E6%9F%93%E8%89%B2%E5%88%86%E5%9D%97/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6665" target="_blank" rel="noopener">题目入口</a><br><b>问：在平面中的两个矩形可以将平面分成多少个区域？</b><br>分析：可以看成是对区域进行染色。<br>先把点离散化，并且在离散化时，将值设为原本离散化值的2倍—&gt;为了使矩形留出空格成块<br>否则，如（0，0）和（1，1）组成的矩形在整个图（假设边为5的正方形图）中显示会如下所示</p>
<a id="more"></a>
<p>-1 -1 0 0 0<br>-1 -1 0 0 0<br> 0  0 0 0 0<br> 0  0 0 0 0<br> 0  0 0 0 0 （-1表示矩形的边，0表示空白处）<br>而因为矩形内也存在区域 所以正确的图应该如下<br>-1 -1 -1 0 0<br>-1  0 -1 0 0<br>-1 -1 -1 0 0<br> 0  0  0 0 0<br> 0  0  0 0 0<br>所以离散化时应该将值设为原本的2倍~<br>然后跑一遍整幅图（此处大小设为了10*10），每跑完一次dfs相当于跑完一个区域，所以跑了多少遍dfs就是有多少个区域–&gt;即答案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="keyword">int</span> a[N][N];</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">5</span>],y[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m[<span class="number">5</span>],n[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">		m[i]=x[i];</span><br><span class="line">		n[i]=y[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sort(m,m+<span class="number">4</span>);</span><br><span class="line">	sort(n,n+<span class="number">4</span>);</span><br><span class="line">	<span class="keyword">int</span> len1=unique(m,m+<span class="number">4</span>)-m;</span><br><span class="line">	<span class="keyword">int</span> len2=unique(n,n+<span class="number">4</span>)-m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">		x[i]=<span class="number">2</span>*(lower_bound(m,m+<span class="number">4</span>,x[i])-m+<span class="number">1</span>);<span class="comment">//为了正方形内空格  可打表观察 </span></span><br><span class="line">		y[i]=<span class="number">2</span>*(lower_bound(n,n+<span class="number">4</span>,y[i])-n+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> zb[<span class="number">4</span>][<span class="number">2</span>]= &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nx,ny;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">		nx=x+zb[i][<span class="number">0</span>];</span><br><span class="line">		ny=y+zb[i][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(nx&gt;=<span class="number">0</span>&amp;&amp;nx&lt;N&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;N&amp;&amp;a[nx][ny]==<span class="number">0</span>) &#123;</span><br><span class="line">			a[nx][ny]=ans;</span><br><span class="line">			dfs(nx,ny);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x[i],&amp;y[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		init();<span class="comment">//离散化</span></span><br><span class="line">		<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">2</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=x[<span class="number">2</span>*j]; i&lt;=x[<span class="number">2</span>*j+<span class="number">1</span>]; i++) &#123;</span><br><span class="line">				a[i][y[<span class="number">2</span>*j]]=a[i][y[<span class="number">2</span>*j+<span class="number">1</span>]]=<span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=y[<span class="number">2</span>*j]; i&lt;=y[<span class="number">2</span>*j+<span class="number">1</span>]; i++) &#123;</span><br><span class="line">				a[x[<span class="number">2</span>*j]][i]=a[x[<span class="number">2</span>*j+<span class="number">1</span>]][i]=<span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;N; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(a[i][j]==<span class="number">0</span>) &#123;</span><br><span class="line">					ans++;</span><br><span class="line">					dfs(i,j);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Roundgod and Milk Tea_hdu6667(贪心)</title>
    <url>/2020/05/29/Roundgod%20and%20Milk%20Tea_hdu6667(%E8%B4%AA%E5%BF%83)/</url>
    <content><![CDATA[<p>这个也是思维题吧。。</p>
<p>used：之前被拿了的奶茶总数</p>
<p>若之前的人拿到的奶茶总数&lt;=当前的奶茶数，说明之前被拿了的奶茶可以换成拿的是当前的奶茶，使得当前的人可以拿除了a[i].p之外的任意奶茶；</p>
<p>若之前的人拿到的奶茶总数&gt;当前的奶茶数，<a id="more"></a>依然是将等量当前的奶茶换成被拿了的奶茶，这样就可以保证当前的人拿的都是除a[i].p以外的奶茶，而多出来的（即used-a[i].p）奶茶则按照他们原先的分配，所以一共能拿的任意奶茶是sum-used</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    ll s,p;</span><br><span class="line">&#125;a[N];</span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">0</span>;<span class="comment">//对于当前的人，可从res杯奶茶中分配</span></span><br><span class="line">    ll used=<span class="number">0</span>;<span class="comment">//已经分派了的牛奶总数</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(used&lt;=a[i].p)&#123;</span><br><span class="line">            res=sum-a[i].p;<span class="comment">//说明被拿了的奶茶可以换成当前的奶茶，使得当前的人可以除了a[i].p拿到任意奶茶</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//依然是将被拿了的奶茶换成等量当前的奶茶，这样就可以保证当前的人拿的是除a[i].p以外的奶茶，而多出来的（即used-a[i].p）奶茶则按照他们原先的分配，所以一共能拿的任意奶茶是sum-used</span></span><br><span class="line">            res=sum-used;</span><br><span class="line">        &#125;</span><br><span class="line">        used += <span class="built_in">min</span>(a[i].s,res);       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,used);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        sum=<span class="number">0</span>;<span class="comment">//总牛奶数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;a[i].s,&amp;a[i].p);</span><br><span class="line">            sum+=a[i].p;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        solve();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>2017沈阳网络赛transaction transaction transaction_hdu6201超级汇点跑SPFA</title>
    <url>/2020/05/29/2017%E6%B2%88%E9%98%B3%E7%BD%91%E7%BB%9C%E8%B5%9Btransaction%20transaction%20transaction_hdu6201%E8%B6%85%E7%BA%A7%E6%B1%87%E7%82%B9%E8%B7%91SPFA/</url>
    <content><![CDATA[<style>
    code{
        color:#C82850 ;
        background:#FAF0F5;
    }
    font{
        color:blue;
        font-weight:bold;
    }
</style>

<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6201" target="_blank" rel="noopener">题目入口</a><br><code>巧妙之处：建立超级源点和超级汇点，让多源问题变成单源问题</code></p>
<ol>
<li>建立超级源点0和超级汇点n+1。</li>
<li>让超级源点（作为起点）连树上所有的点，边权分别为 -a[i]，表示买书花费；</li>
<li>所有树上所有点连接汇点，边权为a[i]，表示卖书花费，</li>
<li>原本的树上两两点之间的边权设为边权为-w，表示花费w。 </li>
<li>然后spfa跑个最长路，答案为dis[超级汇点n+1]。<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">    Edge(<span class="keyword">int</span> _v = <span class="number">0</span>, <span class="keyword">int</span> _cost = <span class="number">0</span>) : v(_v), cost(_cost) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; E[MAXN];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    E[u].push_back(Edge(v, w));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN]; <span class="comment">//在队列标志</span></span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];  <span class="comment">//每个点的入队列次数</span></span><br><span class="line"><span class="keyword">int</span> dist[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n+<span class="number">1</span>; i++)</span><br><span class="line">        dist[i] = -INF;</span><br><span class="line">    vis[start] = <span class="literal">true</span>;</span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    cnt[start] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty())</span><br><span class="line">        que.pop();</span><br><span class="line">    que.push(start);</span><br><span class="line">    <span class="keyword">while</span> (!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = E[u][i].v;</span><br><span class="line">            <span class="keyword">if</span> (dist[v] &lt; dist[u] + E[u][i].cost)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[v] = dist[u] + E[u][i].cost;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    que.push(v);</span><br><span class="line">                    <span class="keyword">if</span> (++cnt[v] &gt; n)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">//cnt[i] 为入队列次数，用来判定是否存在负环回路</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> arr[MAXN],n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            E[i].<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">int</span> s=<span class="number">0</span>,t=n+<span class="number">1</span>;<span class="comment">//超级源点 和 超级汇点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;arr[i]);</span><br><span class="line">            addedge(s,i,-arr[i]);</span><br><span class="line">            addedge(i,t,arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> u,v,w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            addedge(u,v,-w);</span><br><span class="line">            addedge(v,u,-w);<span class="comment">//无向图</span></span><br><span class="line">        &#125;</span><br><span class="line">        SPFA(s,n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dist[t]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Connections in Galaxy War并查集（逆向）</title>
    <url>/2020/05/29/Connections%20in%20Galaxy%20War%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%88%E9%80%86%E5%90%91%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://vjudge.net/problem/ZOJ-3261" target="_blank" rel="noopener">Connections in Galaxy Wara</a><br>参考了一下网上的代码~做个思路记录</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 20005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Q 50005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">逆向思考的并查集</span></span><br><span class="line"><span class="comment">题意：</span></span><br><span class="line"><span class="comment">    给出power值  </span></span><br><span class="line"><span class="comment">    问题：1 查找某点能到达的power值最大的点</span></span><br><span class="line"><span class="comment">         2 删除给出的边（在做删除此边的操作之前的查询，此边依旧可连通）</span></span><br><span class="line"><span class="comment">    若正向思考，则无法删除边</span></span><br><span class="line"><span class="comment">    所以，是逆向的并查集</span></span><br><span class="line"><span class="comment">    方法：  </span></span><br><span class="line"><span class="comment">        先把所有的问题存储起来</span></span><br><span class="line"><span class="comment">        合并除了要删除的边以外！的所有的边---&gt;得出parent树---&gt;以拥有最大power的点为树的根节点</span></span><br><span class="line"><span class="comment">        倒序遍历问题---&gt;若是查询操作，则直接输出该店</span></span><br><span class="line"><span class="comment">                    ---&gt;若是删除边操作，则将该边添加！！！回去树中，以使该边存在于前面的查询操作！！！！！！！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">side</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;s[M];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">problem</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">10</span>];</span><br><span class="line">&#125;p[Q];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span> ,<span class="keyword">bool</span>&gt; mp;</span><br><span class="line"><span class="keyword">int</span> res[Q];</span><br><span class="line"><span class="keyword">int</span> power[N];</span><br><span class="line"><span class="keyword">int</span> parent[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x==parent[x]?x:<span class="built_in">find</span>(parent[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rx=<span class="built_in">find</span>(x),ry=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(power[rx]&gt;power[ry])&#123;</span><br><span class="line">        parent[ry]=rx;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(power[rx]&lt;power[ry])&#123;</span><br><span class="line">        parent[rx]=ry;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rx&lt;ry)&#123;</span><br><span class="line">            parent[ry]=rx;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent[rx]=ry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,q;</span><br><span class="line">    <span class="keyword">int</span> empty=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">        mp.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            parent[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(res,<span class="number">-1</span>,<span class="keyword">sizeof</span>(res));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;power[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s[i].x,&amp;s[i].y);</span><br><span class="line">             <span class="keyword">if</span>(s[i].x&gt;s[i].y)</span><br><span class="line">                 swap(s[i].x,s[i].y);<span class="comment">//因为是无向边，所以统一前小后大的顺序，避免后面删除边时输入的大小顺序不一致，导致mp的值不一样</span></span><br><span class="line">             mp[s[i].x * <span class="number">10000</span> + s[i].y] = <span class="literal">false</span>; <span class="comment">//标记技巧：点的范围是[0,10000)],所以此处的标记保证了x*10000+y不重复！！！</span></span><br><span class="line">        &#125;                             </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q;i++)&#123;<span class="comment">//将查询/破坏信息存储起来</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,p[i].c);</span><br><span class="line">            <span class="keyword">if</span>(p[i].c[<span class="number">0</span>]==<span class="string">'q'</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p[i].x);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p[i].x,&amp;p[i].y);</span><br><span class="line">                <span class="keyword">if</span>(p[i].x&gt;p[i].y)</span><br><span class="line">                    swap(p[i].x,p[i].y);<span class="comment">//记得要做交换</span></span><br><span class="line">               </span><br><span class="line">                mp[p[i].x*<span class="number">10000</span>+p[i].y]=<span class="literal">true</span>;<span class="comment">//将要破坏的边标记起来，</span></span><br><span class="line">            &#125;<span class="comment">//技巧：此处的标记保证了x*10000+y不重复！！！！！！</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;<span class="comment">//将不被破坏的边合并起来</span></span><br><span class="line">            <span class="keyword">if</span>(mp[s[i].x*<span class="number">10000</span>+s[i].y]==<span class="literal">false</span>)&#123;</span><br><span class="line">                merge(s[i].x,s[i].y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=q<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;<span class="comment">//逆序判断，如果当前问题时破环，则把这条边添加回去（因为前面的询问这条边还未破坏）</span></span><br><span class="line">            <span class="keyword">if</span>(p[i].c[<span class="number">0</span>]==<span class="string">'q'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> rx=<span class="built_in">find</span>(p[i].x);</span><br><span class="line">                <span class="keyword">if</span>(power[rx]&gt;power[p[i].x])&#123;</span><br><span class="line">                    res[cnt++]=rx;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res[cnt++]=<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                merge(p[i].x,p[i].y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(empty)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            empty=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=cnt<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>隐式类型转换</title>
    <url>/2020/05/28/%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<style>
    code{
        color:#C82850 ;
        background:#FAF0F5;
    }
    font{
        color:blue;
        font-weight:bold;
    }
</style>

<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>是自动执行的，不需要程序员显示的转换的就是隐式转换，<br>如：<code>int a = 5.2 + 1;</code><br>此时发生了类型转换。因为5.2是一个浮点数，5.2转换为了int类型</p>
<h3 id="内置类型的隐式转换"><a href="#内置类型的隐式转换" class="headerlink" title="内置类型的隐式转换"></a>内置类型的隐式转换</h3><pre><code>太简单，略</code></pre><h3 id="类类型的隐式转换"><a href="#类类型的隐式转换" class="headerlink" title="类类型的隐式转换"></a>类类型的隐式转换</h3><p>如果构造函数只接受一个实参，则它实际上定义了从实参类型转换为此类类型的隐式转换机制，有时我们把这种构造函数称作转换构造函数。<br><code>注意：此处说的是一个实参，不代表形参只有一个，形参可以是多个，其余的有默认值即可</code></p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> &#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">    <span class="comment">//通过设置默认值，定义一个[只有一个实参]时也能调用的构造函数</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    Book(<span class="built_in">string</span> _bookNo, <span class="keyword">double</span> _price = <span class="number">0</span>) : bookNo(_bookNo), price(_price) &#123;&#125;</span><br><span class="line">    <span class="comment">//比较bookNo</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Book&amp; book)</span> </span>&#123; <span class="keyword">return</span> (*<span class="keyword">this</span>).bookNo == book.bookNo; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Book <span class="title">a</span><span class="params">(<span class="string">"one"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a.cmp(<span class="built_in">string</span>(<span class="string">"two"</span>));<span class="comment">//0</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a.cmp(<span class="built_in">string</span>(<span class="string">"one"</span>));<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述例子中，<a id="more"></a>以a.cmp(string(“two”))为例，可见成功调用了cmp比较。但cmp的形参是一个Book类型，而我们传入的实参是string类型，实际上这里就是发生了隐式类类型转换！<br>可以看到，我们有一个<code>Book(string _bookNo, double _price = 0)</code>这样的的构造函数，由于bookNo后的形参采用了默认值，因此我们可以只通过一个实参就调用这个构造函数<br>当我们调用a.cmp(string(“two”))时：</p>
<ol>
<li>string(“two)调用了构造函数——Book(string _bookNo, double _price = 0)，通过这个构造函数<font>生成了一个临时的Book对象b</font></li>
<li>然后上述生成的对象b来作为cmp(const Book&amp; book)中的形参，成功调用cmp函数</li>
</ol>
<p><code>注意：对于类类型的隐式转换，编译器<font>只会</font>自动地执行1步类类型转换</code><br>例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;a.cmp(<span class="string">"two"</span>);<span class="comment">// ×   表达1</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a.cmp(<span class="built_in">string</span>(<span class="string">"two"</span>));<span class="comment">// √  表达2</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a.cmp(Book(<span class="string">"three"</span>));<span class="comment">// √  表达3</span></span><br></pre></td></tr></table></figure>
<p>对于表达1，就需要进行了2次的隐式转换，因此是错误的表达。隐式转换过程如下：</p>
<ul>
<li>第一次是将”two”转换为string</li>
<li>第二次是将第一次转换过来的string转换为Book<br>对于表达2，只进行了string隐式转换为Book，因此可行</li>
</ul>
<h4 id="抑制构造函数定义的隐式转换"><a href="#抑制构造函数定义的隐式转换" class="headerlink" title="抑制构造函数定义的隐式转换"></a>抑制构造函数定义的隐式转换</h4><p>将构造函数声明为<font>explicit</font>即可<br>即将构造函数改为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">explicit Book(string _bookNo, double _price = 0) : bookNo(_bookNo), price(_price) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>参考资料：C++ Prime 第五版</p>
]]></content>
  </entry>
  <entry>
    <title>c++lambda表达式</title>
    <url>/2020/05/27/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<style>
    code{
        color:#C82850 ;
        background:#FAF0F5;
    }

</style>

<h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><ol>
<li>lambda表达式其实可以直接看做是一个函数</li>
<li>lambda表达式实际上可以转换成等价的类！</li>
</ol>
<h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><p><code>[capture](parameters) mutable ->return-type{statement}</code></p>
<h3 id="最大优势："><a href="#最大优势：" class="headerlink" title="最大优势："></a>最大优势：</h3><p>可以以值传递/引用方式捕捉到上下文的变量，共lambda函数使用</p>
<h3 id="用法详细说明："><a href="#用法详细说明：" class="headerlink" title="用法详细说明："></a>用法详细说明：</h3><a id="more"></a>
<p>1.<code>[capture]</code>：捕捉列表。捕捉到的变量供lamb函数使用。相当于类中的成员变量</p>
<p>2.<code>(parameters)</code>：函数的参数列表。如果不需要参数传递，则可以连同括号“()”一起省略;</p>
<p>3.<code>mutable</code>：mutable修饰符。默认情况下，Lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）;</p>
<p>4.<code>->return-type</code>：返回类型。用追踪返回类型形式声明函数的返回类型。我们可以在不需要返回值的时候也可以连同符号”-&gt;”一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导;</p>
<p>5.<code>{statement}</code>：函数体。除了可以使用参数列表中的参数之外，还可使用捕获到的变量。</p>
<h4 id="其中：-captrue-规则"><a href="#其中：-captrue-规则" class="headerlink" title="其中：[captrue]规则"></a>其中：[captrue]规则</h4><p>1.[var]表示值传递方式捕捉变量var；<br>2.[=]表示值传递方式捕捉所有父作用域的变量（包括this）；<br>3.[&amp;var]表示引用传递捕捉变量var；<br>4.[&amp;]表示引用传递方式捕捉所有父作用域的变量（包括this）；<br>5.[this]表示值传递方式捕捉当前的this指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cmp</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// z=5;//错误，const成员函数不可以修改非static成员变量</span></span><br><span class="line">        <span class="keyword">return</span> z &lt; a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//--------------例1----------------</span></span><br><span class="line">    <span class="keyword">int</span> z = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//该lambda表达式就等同于Cmp类，[]里的值相当于类中的成员变量,</span></span><br><span class="line">    <span class="comment">//(const int a)相当于类中cmp函数的形参列表</span></span><br><span class="line">    <span class="keyword">auto</span> const_a = [z](<span class="keyword">const</span> <span class="keyword">int</span> a) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="comment">// z=5;//这句是错的，因为lambda表达式不带mutable就是一个const函数，而const修饰成员函数是不可以改变类中非static成员变量的</span></span><br><span class="line">        <span class="keyword">return</span> z &gt; a;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"const_a(2)="</span> &lt;&lt; const_a(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------------例2----------------</span></span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> mutable_val = [=]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        val = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"_mutable_inner_val="</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 3</span></span><br><span class="line">    &#125;;</span><br><span class="line">    mutable_val();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"mutable_val="</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 0</span></span><br><span class="line">    <span class="comment">/* 使用了mutable改变了lambda函数默认的const属性，</span></span><br><span class="line"><span class="comment">     * 但以值传递的方式在lambda函数体内修改val,只不过是修改了拷贝过来的局部变量val,</span></span><br><span class="line"><span class="comment">     * 就像swap(inta,int b)&#123;int t;t=a,a=b,b=t;&#125;,</span></span><br><span class="line"><span class="comment">     * 形参ab都是值传递过来的,当调用的时候使用的是swap(c,d),</span></span><br><span class="line"><span class="comment">     * 等完成了swap函数体,并不会改变实参,也就不会交换cd的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重点-当使用引用时，注意点！！！</span></span><br><span class="line">    <span class="comment">//--------------例3----------------</span></span><br><span class="line">    val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> const_ref = [&amp;]() &#123; val = <span class="number">4</span>; &#125;;</span><br><span class="line">    const_ref();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"const_ref_val="</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="comment">// val=4  虽在const函数，但改变了val!!!</span></span><br><span class="line">    <span class="comment">//--------------例4----------------</span></span><br><span class="line">    <span class="keyword">auto</span> mutable_ref_lambda = [&amp;]() <span class="keyword">mutable</span> &#123; val = <span class="number">5</span>; &#125;;</span><br><span class="line">    mutable_ref_lambda();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"mutable_ref_val"</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// val=5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考资料:<a href="https://blog.csdn.net/u010984552/article/details/53634513" target="_blank" rel="noopener">https://blog.csdn.net/u010984552/article/details/53634513</a></p>
]]></content>
  </entry>
  <entry>
    <title>hexo下建blog的坑点</title>
    <url>/2020/03/17/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E6%9D%A5%E5%BF%85%E5%8A%9B%E8%AF%84%E8%AE%BA%E5%9D%91%E7%82%B9/</url>
    <content><![CDATA[<style>
    code{
        color:#C82850 ;
        background:#FAF0F5;
    }

</style>

<h2 id="坑点1——来必力评论不显示"><a href="#坑点1——来必力评论不显示" class="headerlink" title="坑点1——来必力评论不显示"></a>坑点1——来必力评论不显示</h2><p> 用了最新版的next，找了很多篇配置讲解都是说，注册了来必力之后，把“来必力安装代码”中data-uid的值，直接替换掉主题配置文件中设置livere_uid的值就好，但是弄了很久，也不知道是我的next问题还是怎么样，评论区一直没加载进来。</p>
<h3 id="获取来必力data-uid"><a href="#获取来必力data-uid" class="headerlink" title="获取来必力data-uid"></a>获取来必力data-uid</h3><p><img src="/2020/03/17/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E6%9D%A5%E5%BF%85%E5%8A%9B%E8%AF%84%E8%AE%BA%E5%9D%91%E7%82%B9/livere0.png" alt="avatar"></p>
<h3 id="替换主题配置文件-config-yml中的livere-uid"><a href="#替换主题配置文件-config-yml中的livere-uid" class="headerlink" title="替换主题配置文件_config.yml中的livere_uid"></a>替换主题配置文件_config.yml中的livere_uid</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># LiveRe comments system</span></span><br><span class="line"><span class="comment"># You can get your uid from https://livere.com/insight/myCode (General web site)</span></span><br><span class="line"><span class="attr">livere_uid:</span> <span class="string">MTAyMC80OTE1MS8yNTY0NQ==</span></span><br></pre></td></tr></table></figure>




<p> 直到我换了next四个主题中的其中一个之后，评论区就科幻的成功加载进来了！！！</p>
<a id="more"></a>
<h3 id="换主题方法"><a href="#换主题方法" class="headerlink" title="换主题方法"></a>换主题方法</h3><p>在主题配置文件(themes/next/config.yml)中，搜索Schemes就会找到主题模块，切换成你想要的主题即可。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/17/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E6%9D%A5%E5%BF%85%E5%8A%9B%E8%AF%84%E8%AE%BA%E5%9D%91%E7%82%B9/result0.jpg" alt="result.png"><br>不过，试了好多次之后又发现，有时候评论区也没有加载进来，个人觉得…可能是因为本身就加载慢。</p>
<h2 id="坑点2——文章导入本地图片不显示"><a href="#坑点2——文章导入本地图片不显示" class="headerlink" title="坑点2——文章导入本地图片不显示"></a>坑点2——文章导入本地图片不显示</h2><p>按网上常规步骤弄完，图片仍不显示！</p>
<h3 id="博客文章导入图片步骤"><a href="#博客文章导入图片步骤" class="headerlink" title="博客文章导入图片步骤"></a>博客文章导入图片步骤</h3><p>1.去站点配置文件_config.yml中：将<code>post_asset_folder: false</code>改为<code>post_asset_folder: true</code><br>2.站点下安装插件<code><font>npm install <a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="noopener">https://github.com/CodeFalling/hexo-asset-image</a> -- save<font></font></font></code><br>3.运行<code><font>hexo n "你的文件名"</font></code>，就会在source/_posts/路径下分别生成名为<code>"你的文件名.md"</code>的md文件和文件夹。将你要在文章中<u>引入的图片</u>放到这个文件夹下即可。</p>
<p>但是！并没有成功显示图片</p>
<h3 id="替换插件内容"><a href="#替换插件内容" class="headerlink" title="替换插件内容"></a>替换插件内容</h3><p>最后在CSND看到<a href="https://blog.csdn.net/xjm850552586/article/details/84101345" target="_blank" rel="noopener">一篇文章</a>，原来是因为前面安装的hexo-asset-image这个插件有bug，于是在/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">'.'</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">'after_post_render'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> config = hexo.config;</span><br><span class="line"><span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">        <span class="keyword">var</span> link = data.permalink;</span><br><span class="line">    <span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".</span></span><br><span class="line">    <span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">'excerpt'</span>, <span class="string">'more'</span>, <span class="string">'content'</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">        xmlMode: <span class="literal">false</span>,</span><br><span class="line">        lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">        decodeEntities: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    $(<span class="string">'img'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($(<span class="keyword">this</span>).attr(<span class="string">'src'</span>))&#123;</span><br><span class="line">            <span class="comment">// For windows style path, we replace '\' to '/'.</span></span><br><span class="line">            <span class="keyword">var</span> src = $(<span class="keyword">this</span>).attr(<span class="string">'src'</span>).replace(<span class="string">'\\'</span>, <span class="string">'/'</span>);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">            !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">            <span class="comment">// For "about" page, the first part of "src" can't be removed.</span></span><br><span class="line">            <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">            <span class="keyword">var</span> linkArray = link.split(<span class="string">'/'</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">''</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">var</span> srcArray = src.split(<span class="string">'/'</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">''</span> &amp;&amp; elem != <span class="string">'.'</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">                srcArray.shift();</span><br><span class="line">            src = srcArray.join(<span class="string">'/'</span>);</span><br><span class="line">            $(<span class="keyword">this</span>).attr(<span class="string">'src'</span>, config.root + link + src);</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">"update link as:--&gt;"</span>+config.root + link + src);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">"no src attr, skipped..."</span>);</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/17/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E6%9D%A5%E5%BF%85%E5%8A%9B%E8%AF%84%E8%AE%BA%E5%9D%91%E7%82%B9/result.jpg" alt="result.png"></p>
<h3 id="成功！撒花onYeah"><a href="#成功！撒花onYeah" class="headerlink" title="成功！撒花onYeah!"></a><center>成功！撒花onYeah!</center></h3>]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><a id="more"></a>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
